# -*- coding: utf-8 -*-

from __future__ import division


__author__ = """John Kirkham"""
__email__ = "kirkhamj@janelia.hhmi.org"


from ._version import get_versions
__version__ = get_versions()['version']
del get_versions


import itertools

import numpy

import dask.array

from . import _compat
from . import _pycompat
from . import _utils


def center_of_mass(input, labels=None, index=None):
    """
    Calculate the center of mass of the values of an array at labels.

    Parameters
    ----------
    input : ndarray
        Data from which to calculate center-of-mass. The masses can either
        be positive or negative.
    labels : ndarray, optional
        Labels for objects in `input`, as generated by `ndimage.label`.
        Only used with `index`.  Dimensions must be the same as `input`.
    index : int or sequence of ints, optional
        Labels for which to calculate centers-of-mass. If not specified,
        all labels greater than zero are used.  Only used with `labels`.

    Returns
    -------
    center_of_mass : tuple, or list of tuples
        Coordinates of centers-of-mass.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )

    # SciPy transposes these for some reason.
    # So we do the same thing here.
    # This only matters if index is some array.
    index = index.T

    input_mtch_sum = sum(input, labels, index)

    input_i = _compat._indices(
        input.shape, dtype=numpy.int64, chunks=input.chunks
    )

    input_i_wt = input[None] * input_i

    input_i_wt_mtch_sum = []
    for i in _pycompat.irange(len(input_i_wt)):
        input_i_wt_mtch_sum.append(sum(input_i_wt[i], labels, index))
    input_i_wt_mtch_sum = dask.array.stack(input_i_wt_mtch_sum, axis=-1)

    com_lbl = input_i_wt_mtch_sum / input_mtch_sum[..., None]

    return com_lbl


def labeled_comprehension(input,
                          labels,
                          index,
                          func,
                          out_dtype,
                          default,
                          pass_positions=False):
    """
    Roughly equivalent to [func(input[labels == i]) for i in index].

    Sequentially applies an arbitrary function (that works on array_like input)
    to subsets of an n-D image array specified by `labels` and `index`.
    The option exists to provide the function with positional parameters as the
    second argument.

    Parameters
    ----------
    input : array_like
        Data from which to select `labels` to process.
    labels : array_like or None
        Labels to objects in `input`.
        If not None, array must be same shape as `input`.
        If None, `func` is applied to raveled `input`.
    index : int, sequence of ints or None
        Subset of `labels` to which to apply `func`.
        If a scalar, a single value is returned.
        If None, `func` is applied to all non-zero values of `labels`.
    func : callable
        Python function to apply to `labels` from `input`.
    out_dtype : dtype
        Dtype to use for `result`.
    default : int, float or None
        Default return value when a element of `index` does not exist
        in `labels`.
    pass_positions : bool, optional
        If True, pass linear indices to `func` as a second argument.
        Default is False.

    Returns
    -------
    result : ndarray
        Result of applying `func` to each of `labels` to `input` in `index`.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )
    out_dtype = numpy.dtype(out_dtype)
    default = numpy.array(default, dtype=out_dtype)[()]
    pass_positions = bool(pass_positions)

    indices = _utils._ravel_shape_indices(
        input.shape, dtype=numpy.int64, chunks=input.chunks
    )

    lbl_mtch = _utils._get_label_matches(labels, index)

    lbl_mtch_any = lbl_mtch.any(
        axis=tuple(_pycompat.irange(index.ndim, lbl_mtch.ndim))
    )

    result = numpy.empty(index.shape, dtype=object)
    for i in itertools.product(*[_pycompat.irange(j) for j in index.shape]):
        args = (input[lbl_mtch[i]],)
        if pass_positions:
            args += (indices[lbl_mtch[i]],)

        result[i] = dask.delayed(_utils._labeled_comprehension_func)(
            func, out_dtype, default, lbl_mtch_any[i], *args
        )
        result[i] = dask.array.from_delayed(result[i], tuple(), out_dtype)

    for i in _pycompat.irange(result.ndim - 1, -1, -1):
        p = itertools.product(*[
            _pycompat.irange(e) for e in index.shape[:i]
        ])
        result2 = result[..., 0]
        for j in p:
            result2[j] = dask.array.stack(
                result[j].tolist(), axis=0
            )
        result = result2
    result = result[()]

    return result


def mean(input, labels=None, index=None):
    """
    Calculate the mean of the values of an array at labels.

    Parameters
    ----------
    input : array_like
        Array on which to compute the mean of elements over distinct
        regions.
    labels : array_like, optional
        Array of labels of same shape, or broadcastable to the same shape as
        `input`. All elements sharing the same label form one region over
        which the mean of the elements is computed.
    index : int or sequence of ints, optional
        Labels of the objects over which the mean is to be computed.
        Default is None, in which case the mean for all values where label is
        greater than 0 is calculated.

    Returns
    -------
    out : array_like
        Sequence of same length as `index`, with the mean of the different
        regions labeled by the labels in `index`.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )

    input_sum = sum(input, labels, index)
    input_norm = sum(
        dask.array.ones(input.shape, dtype=input.dtype, chunks=input.chunks),
        labels,
        index
    )

    com_lbl = input_sum / input_norm

    return com_lbl


def standard_deviation(input, labels=None, index=None):
    """
    Calculate the standard deviation of the values of an n-D image array,
    optionally at specified sub-regions.

    Parameters
    ----------
    input : array_like
        Nd-image data to process.
    labels : array_like, optional
        Labels to identify sub-regions in `input`.
        If not None, must be same shape as `input`.
    index : int or sequence of ints, optional
        `labels` to include in output.  If None (default), all values where
        `labels` is non-zero are used.

    Returns
    -------
    standard_deviation : float or ndarray
        Values of standard deviation, for each sub-region if `labels` and
        `index` are specified.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )

    std_lbl = dask.array.sqrt(variance(input, labels, index))

    return std_lbl


def sum(input, labels=None, index=None):
    """
    Calculate the sum of the values of the array.

    Parameters
    ----------
    input : array_like
        Values of `input` inside the regions defined by `labels`
        are summed together.
    labels : array_like of ints, optional
        Assign labels to the values of the array. Has to have the same shape as
        `input`.
    index : array_like, optional
        A single label number or a sequence of label numbers of
        the objects to be measured.

    Returns
    -------
    sum : ndarray or scalar
        An array of the sums of values of `input` inside the regions defined
        by `labels` with the same shape as `index`. If 'index' is None or scalar,
        a scalar is returned.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )

    lbl_mtch = _utils._get_label_matches(labels, index)

    input_mtch = dask.array.where(
        lbl_mtch, input[index.ndim * (None,)], input.dtype.type(0)
    )

    input_mtch = input_mtch.astype(numpy.float64)

    sum_lbl = input_mtch.sum(
        axis=tuple(_pycompat.irange(index.ndim, input_mtch.ndim))
    )

    return sum_lbl


def variance(input, labels=None, index=None):
    """
    Calculate the variance of the values of an n-D image array, optionally at
    specified sub-regions.

    Parameters
    ----------
    input : array_like
        Nd-image data to process.
    labels : array_like, optional
        Labels defining sub-regions in `input`.
        If not None, must be same shape as `input`.
    index : int or sequence of ints, optional
        `labels` to include in output.  If None (default), all values where
        `labels` is non-zero are used.

    Returns
    -------
    variance : array-like
        Values of variance, for each sub-region if `labels` and `index` are
        specified.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )

    input_2_mean = mean(dask.array.square(input), labels, index)
    input_mean_2 = dask.array.square(mean(input, labels, index))

    var_lbl = input_2_mean - input_mean_2

    return var_lbl
